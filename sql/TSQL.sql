-- DDL --
-- SQL SERVER REPLICATION --> Bir yerdeki sunucu ile başka sunucu arası veri transferi/Bir verinin farklı konumlardaki sunucularda tutulması
-- SQL RDBMS --> İlişkisel Veritabanı Yönetim Sistemi
-- MasterDB --> Sistem conf/kullanıcılar ve yetkileri/Sistem Dosyaları/Erişim yetkileri/Temel conf
-- ModelDB --> Şablon veritabanı/Her oluşturulacak veritabanı ModelDB'nin bir kopyası
-- MsDB --> Periyodik olarak çalıştırılam her türlü işlem burada tutulur(joblar,schedulelar,alertler)
-- TempDB --> Geçici tabloların oluşturulduğu işlemler burada gerçekleşir/Aggregation işlemler(by,order by,sum,count,max, min gibi)
-- DDL Commands --> CREATE / ALTER / DROP / TRUNCATE
CREATE DATABASE TEST -- Database oluştur

DROP DATABASE TEST --- Database sil

CREATE TABLE ISIMLER (
	ID INT IDENTITY(1,1),ISIM VARCHAR(20)
) -- Tablo oluştur

INSERT INTO ISIMLER(ISIM)VALUES('MEMET') -- kayıt gir

SELECT*FROM ISIMLER -- tablodaki verilerin hepsini çağır

DROP TABLE ISIMLER -- tabloyu sil

ALTER TABLE ISIMLER ADD TELEFON VARCHAR(12) -- kolon ekleme

ALTER TABLE ISIMLER ADD SOYISIM VARCHAR(12) -- kolon ekleme

ALTER TABLE ISIMLER DROP COLUMN SOYISIM -- kolon sil

ALTER TABLE ISIMLER ALTER COLUMN TELEFON VARCHAR(50) -- varolan bir kolonun içeriğini değiştirme

TRUNCATE TABLE ISIMLER -- tablonun içerisindeki verileri siler

DECLARE @ISIM AS VARCHAR(100) -- değişken tanımlama
SET @ISIM='MEHMET' -- değişkene değer atama
DECLARE @SOYISIM AS VARCHAR(100)='DEMİREL' -- değişken tanımlama ve değişkene değer atama
SELECT @ISIM,@SOYISIM -- görüntüleme


DECLARE  -- bu şekilde ister tek bir DECLARE ile birden fazla değişken oluşturabilirsiniz
	@SAYI1 AS INTEGER,
	@SAYI2 AS INTEGER,
	@SAYI3 AS INTEGER

-- OR --

DECLARE @SAYI1 AS INTEGER=10 -- tanımlanan bir değişkene bu şekilde atama yapılabilir
DECLARE @SAYI2 AS INTEGER
SET @SAYI2='20' -- tanımlanan değişkene bu şekilde de atama yapılabilir (uygulamış olduğunuz operasyona göre atama şekillerini nasıl kullanacağınız size kalmıştır)
DECLARE @TOPLAM2 AS INTEGER
SET @TOPLAM2=@SAYI1+@SAYI2

SELECT @SAYI1 AS SAYI1,@SAYI2 AS SAYI2,@SAYI1+@SAYI2 AS TOPLAM,@TOPLAM2 AS TOPLAM2 -- alias

-- TABLODAKİ DEĞERLERİ DEĞİŞKENE ATAMA --

DECLARE @ISIM AS VARCHAR(50)
DECLARE @TELEFON AS VARCHAR(50)
SELECT 
@ISIM=NAMESURNAME,@TELEFON=TELNR FROM CUSTOMERS WHERE ID=2
SELECT @ISIM,@TELEFON


-- DATE TIME --
DECLARE @DATE AS DATETIME
SET @DATE=GETDATE()
SELECT @DATE TARIH

-- String functions --

-- SUBSTRING --

DECLARE @KELIME AS VARCHAR(50)
SET @KELIME='MERHABA DÜNYA'
SELECT SUBSTRING(@KELIME,1,7) -- BELİRLENMİŞ İNDEKSLER ARASI CHARLARI AYIRIR
SELECT SUBSTRING(@KELIME,9,13)

-- LOWER, UPPER --
DECLARE @KELIME AS VARCHAR(50)
SET @KELIME='MERHABA DÜNYA'
SELECT LOWER(@KELIME) -- KELİMELERİN HEPSİNİ BÜYÜK HARF YAPAR
SELECT UPPER(@KELIME) -- KELİMELERİN HEPSİNİ KÜÇÜK HARF YAPAR

-- String birleştirme --
DECLARE @AD AS VARCHAR(50)='MEHMET'
DECLARE @SOYAD AS VARCHAR(50)='DEMİREL'
SELECT @AD+' '+@SOYAD

-- RIGHT, LEFT --
DECLARE @KELIME AS VARCHAR(50)
SET @KELIME='MERHABA DÜNYA'
--SELECT LEFT(@KELIME,7) -- SOLDAN İTİBAREN 7 KARAKTER
SELECT RIGHT(@KELIME,5) -- SAĞDAN İTİBAREN 5 KARAKTER

-- LTRIM,RTRIM,TRIM --
DECLARE @KELIME AS VARCHAR(100)='   MERHABA DÜNYA   '
SELECT LTRIM(@KELIME) -- SOL KISIMDAKI BOŞLUKLARI SİLER
SELECT RTRIM(@KELIME) -- SAĞ KISIMDAKİ BOŞLUKLARI SİLER
SELECT TRIM(@KELIME) -- SAĞ VE SOLDAKİ BOŞLUKLARI SİLER
SELECT LTRIM(RTRIM(@KELIME)) -- TRIM İLE AYNI

-- REPLACE --
DECLARE @KELIME AS VARCHAR(100)='MERHABA DÜNYA'
SELECT REPLACE(@KELIME,'Ü','U') -- HARF DEĞİŞİMİ
REPLACE(@KELIME,'MERHABA','HELLO') -- KELIME DEĞİŞİMİ
SELECT REPLACE(REPLACE(@KELIME,'MERHABA','HELLO'),'DÜNYA','WORLD')

-- LEN --
DECLARE @KELIME AS VARCHAR(100)='MERHABA DÜNYA'
SELECT LEN(@KELIME) -- CÜMLE VEYA KELIME UZUNLUGU

-- STRING_SPLIT --
DECLARE @KELIME AS VARCHAR(100)='MERHABA DÜNYA'
SELECT
* FROM string_split(@KELIME,' ') -- KELIMELERI TABLO DEĞERİNE DÖNÜŞTÜRÜR
DECLARE @KELIME AS VARCHAR(100)='MERHABA BEN MEHMET SQL EĞİTİMİ ALIYORUM'
SELECT
* FROM string_split(@KELIME,' ')

-- DATE TIME FUNCTİONS --

-- DATEADD --
DECLARE @TARIH AS DATETIME
	SET @TARIH='2021-01-01 16:21:37' 
DECLARE @TARIH2 AS DATETIME
	SET @TARIH2=DATEADD(MONTH,6,@TARIH) -- GÜN AY YIL GİBİ EKLEMELER
SELECT @TARIH,@TARIH2

-- DATEDIFF --
DECLARE @TARIH AS DATETIME
	SET @TARIH='2018-01-01 18:18:12' -- İKİ TARİH ARASI FARK GÜN AY YIL
DECLARE @TARIH2 AS DATETIME
	SET @TARIH2='2021-01-01 21:21:21'
SELECT DATEDIFF(YEAR,@TARIH,@TARIH2) AS YIL
SELECT DATEDIFF(DAY,@TARIH,@TARIH2) AS GUN
SELECT DATEDIFF(WEEK,@TARIH,@TARIH2) AS HAFTA
SELECT DATEDIFF(MONTH,@TARIH,@TARIH2) AS AY

-- DATEFROMPARTS --
SELECT DATEFROMPARTS(2021,8,21)
DECLARE @TARIH AS DATETIME -- TARIH FORMATINA DÖNÜŞTÜRME
SET @TARIH=DATEFROMPARTS(2021,8,21)
SELECT @TARIH

-- DATEPART --
DECLARE @TARIH AS DATETIME
	SET @TARIH='2018-01-01 18:18:12' -- TARIHTEN ISTEDIGIMIZ ALANI GETIRTME
SELECT DATEPART(YEAR,@TARIH)

-- GETDATE --
SELECT GETDATE() -- ŞU ANKİ ZAMANI GETİRİR
DECLARE @TARIH AS DATE -- YAŞ HESAPLAMA
	SET @TARIH='1996-10-08'
SELECT DATEDIFF(YEAR,@TARIH,GETDATE())

-- WHILE --

DECLARE @I AS INT = 0
WHILE @I<10
BEGIN
INSERT INTO TARIHLER (TARIH) VALUES(GETDATE()) -- TARIHLER BI TABLODAN GELMEKTEDİR 
WAITFOR DELAY '00:00:01'
PRINT @I
SET @I=@I+1
END
SELECT * FROM TARIHLER
----------------------------------------------
SELECT * FROM ISIM
SELECT * FROM SOYISIM
SELECT * FROM KISILER
DECLARE @AD AS VARCHAR(50)
DECLARE @SOYAD AS VARCHAR(50)
DECLARE @I AS INT=0

WHILE @I<1
	BEGIN
SELECT @AD=AD FROM ISIM WHERE ID=ROUND (RAND()*1000,0) -- @AD = AD TABLOMUZDA BULUNAN AD KOLONUNU OLUŞTURMUŞ OLDUĞUMUZ DEĞİŞKENE AKTARIR
SELECT @SOYAD=SOYAD FROM SOYISIM WHERE ID=ROUND (RAND()*1000,0)
SELECT @AD,@SOYAD
INSERT INTO KISILER(AD,SOYAD) VALUES (@AD,@SOYAD)
SET @I=@I+1
	END
-- STRING VARIABLES--
CHAR(N)
NCHAR
VARCHAR(N,MAX)
NVARCHAR(N,max)
TEXT
NTEXT
-- NUMBER VARIABLES--
INT
BIT
BIGINT
SMALLINT
TINYINT
DECIMAL OR NUMERIC
FLOAT(N)
MONEY
REAL
SMALLMONEY
BIT(BOOLEAN)

BINARY(N)
VARBINARY(N)
IMAGE
-- DATE VARIABLES --
DATE
SMALLDATETIME
DATETIME
DATETIME2
TIME
DATETIMEOFFSET

----------------------------------------------------------------------------------------------------------------------------------------

DECLARE 
	@I AS INT=1,
	@NAMES AS VARCHAR(50),
	@IDS AS INT=1
WHILE(@I<=1)
	BEGIN
	SELECT @NAMES=NAMESURNAME FROM CUSTOMERS WHERE(@IDS=ID)
	SELECT @NAMES AS ISIMLER
	SET @IDS+=1
	SET @I+=1
	END

INSERT INTO CUSTOMERS(NAMESURNAME,GENDER,BIRTHDATE,CITY,TOWN,TELNR,NAME_,SURNAME) -- TABLOYA BİR VEYA BİRDEN ÇOK KAYIT EKLEME SORGUSUDUR, YANİ KISACA EKLEME SORGUSUDUR
VALUES('MEHMET DEMİREL','E','1999-08-10','OSMANIYE','KADIRLI','1111111111','MEHMET','DEMİREL')

INSERT INTO CUSTOMERS([NAME SURNAME], [GENDER], [BIRTHDATE], [CITY], [TOWN], [TELNR], [NAME_], [SURNAME]) -- KÖŞELİ PARANTEZLERİN SEBEBİ EĞER TANIMLANMIŞ DEĞİŞKENİMİZDE BOŞLUK(SPACE) VARSA ÇIAKBİLECEK HATALARIN ÖNÜNE GEÇEBİLMEK
VALUES('MEHMET DEMİREL','E','1999-08-10','OSMANIYE','KADIRLI','1111111111','MEHMET','DEMİREL')



SELECT * FROM CUSTOMERS WHERE(ID='2512013') -- ID'Sİ 2512013 OLAN KULLANICIYI BİZİM İÇİN GETİREN SORGU

UPDATE CUSTOMERS -- BİR TABLODAKİ VAROLAN KAYITLARI DEĞİŞTİRMEK/GÜNCELLEMEK İÇİN KULLANILIR (ID OTOMATİK ARTAN OLDUĞU İÇİN ID DAHİL DEĞİLDİR BU SORGUYA, LAKİN OTOMATİK ARTAN DEĞİLSE ÖRN: SON EKLENMİŞ KULLANICINIZIN ID'SINI ALARAK BIR ARTIRAN VEYA STRING BIR YAPIDA OLAN ID ISE BUNA DAHIL DEGIL)
	SET 
	NAMESURNAME='AHMET DEMİREL',
	GENDER='E', 
	BIRTHDATE='1999-08-10',
	CITY='OSMANIYE',
	TOWN='KADIRLI',
	TELNR='111111111',
	NAME_='AHMET',
	SURNAME='DEMİREL'
WHERE(ID='2512013')

UPDATE CUSTOMERS
	SET AGE=DATEDIFF(YEAR,BIRTHDATE,GETDATE())


----------------------------------------------------------------------------------------------------------------------------------------
-- BASİT ŞARTLI SORGULAR --
SELECT * FROM CUSTOMERS
SELECT * FROM CUSTOMERS WHERE(CITY='İZMİR') -- CITY'Sİ  "İZMİR" OLANI GETİR 
SELECT * FROM CUSTOMERS WHERE(CITY<>'İZMİR') -- CITY'Sİ "İZMİR" OLMAYANI GETİR
SELECT * FROM CUSTOMERS WHERE(NOT CITY='İZMİR') -- CITY'Sİ "İZMİR" OLMAYANI/İÇERMEYENİ GETİR
SELECT * FROM CUSTOMERS WHERE(GENDER='E')
SELECT * FROM CUSTOMERS WHERE(BIRTHDATE>'1990-01-01')
SELECT * FROM CUSTOMERS WHERE(BIRTHDATE BETWEEN '1990-01-01' AND '1992-01-01') -- 1990  VE 1994 ARASINDA DOĞANLARI GETIR
SELECT * FROM CUSTOMERS WHERE(AGE BETWEEN 20 AND 30) 
SELECT *FROM CUSTOMERS WHERE(BIRTHDATE='1998-01-02')
SELECT * FROM CUSTOMERS WHERE(NAMESURNAME LIKE 'ALİ%') -- ADININ İLK 3 HANESİ ALİ OLANI GETİR
SELECT * FROM CUSTOMERS WHERE(NAMESURNAME LIKE '%ALİ') -- YUKARDAKİ İŞLEMİN TAM TERSİ
SELECT * FROM CUSTOMERS WHERE(NAMESURNAME LIKE '%ALİ%') -- HERHANGİ BİR YERİNDE ALİ İBARESİ GEÇENİ GETİR
SELECT * FROM CUSTOMERS WHERE(CITY IN('İSTANBUL','ANKARA')) -- İSTANBUL ANKARA İÇERENLERİ GETİR
SELECT * FROM CUSTOMERS WHERE(CITY NOT IN('İSTANBUL','ANKARA')) -- YUKARDAKİNİN TAM TERSİ

-- SQL OPERATORS -- 
/*
	+	Add --> EKLE/TOPLA
	-	Subtract --> ÇIKAR
	*	Multiply --> ÇARP
	/	Divide --> BÖL
	%	Modulo --> BÖLÜMDEN KALANI BULMA ÖRN: 5/2 = 1 BURADAKİ SONUCU YANİ 1'İ BULMA

	&	AND --> VE/DAHİL
	|	OR --> VEYA
	^	Exclusive OR  --> MANTIKSAL VEYA

	=	Equal --> EŞİT/EŞİTTİR
	>	Greater than --> BÜYÜKTÜR
	<	Less than --> KÜÇÜKTÜR
	>=	Greater than or equal to --> BÜYÜK EŞİTTİR	
	<=	Less than or equal to -->	KÜÇÜKEŞİTTRİ
	<>	Not equal to --> EŞİT DEĞİL
	!=  Not equal to --> EŞİT DEĞİL

	+=	Add equals --> EŞİTTİRE EKLE ÖRN:
										DECLARE @SAYI AS INT = 1
										SET @SAYI += 1
										SELECT @SAYI
										ÇIKTI 2 OLUR
	-=	Subtract equals --> EŞİTTİRDEN ÇIKAR ÖRN:
										DECLARE @SAYI AS INT = 2
										SET @SAYI -= 1
										SELECT @SAYI
										ÇIKTI 1 OLUR
	*=	Multiply equals --> EŞİTTİRLE ÇARP ÖRN:
										DECLARE @SAYI AS INT = 2
										SET @SAYI *= 3
										SELECT @SAYI
										ÇIKTI + OLUR
	/=	Divide equals --> EŞİTTİRLE BÖL ÖRN:
										DECLARE @SAYI AS INT = 5
										SET @SAYI /= 2
										SELECT @SAYI
										ÇIKTI 2 OLUR
	%=	Modulo equals --> EŞİTTİRE KALANI ATA ÖRN:
										DECLARE @SAYI AS INT = 5
										SET @SAYI %= 2
										SELECT @SAYI
										ÇIKTI 1 OLUR

	ALL -->	TRUE if all of the subquery values meet the condition	
	AND -->	TRUE if all the conditions separated by AND is TRUE	
	ANY -->	TRUE if any of the subquery values meet the condition	
	BETWEEN -->	TRUE if the operand is within the range of comparisons	
	EXISTS -->	TRUE if the subquery returns one or more records	
	IN -->	TRUE if the operand is equal to one of a list of expressions
	LIKE -->	TRUE if the operand matches a pattern	
	NOT -->	Displays a record if the condition(s) is NOT TRUE	
	OR -->	TRUE if any of the conditions separated by OR is TRUE	
	SOME -->	TRUE if any of the subquery values meet the conditio
	
	FAZLADAN KAYNAK
		https://medium.com/gokhanyavas/t-sql-operat%C3%B6rler-f1db5705a3bb

*/
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE CUSTOMERS -- UPDATE İLE BETWEEN KULLANIMI
	SET BIRTHDATE='1998-01-02'
	WHERE(BIRTHDATE BETWEEN '1990-01-01' AND '1992-01-01')

UPDATE CUSTOMERS
	SET GENDER='ERKEK'
	WHERE(GENDER='E')

UPDATE CUSTOMERS
	SET GENDER='KADIN'
	WHERE(GENDER='K')

SELECT TOP(100) * FROM CUSTOMERS
UPDATE CUSTOMERS
	SET GENDER='E'
	WHERE(GENDER='ERKEK')

UPDATE CUSTOMERS
	SET GENDER='K'
	WHERE(GENDER='KADIN')

----------------------------------------------------------------------------------------------------------------------------------------

CREATE TABLE MEMET(
	ID  INT IDENTITY(1,1) NOT NULL,
	NAMESURNAME VARCHAR(50),
	AGE INT
)
----------------------------------------------------------------------------------------------------------------------------------------
SELECT * FROM CUSTOMERS ORDER BY(NAMESURNAME)ASC
SELECT * FROM CUSTOMERS ORDER BY(NAMESURNAME)DESC
SELECT * FROM CUSTOMERS WHERE(CITY='İSTANBUL') ORDER BY(NAMESURNAME)

----------------------------------------------------------------------------------------------------------------------------------------
/*
	MIN(EXPRESSİON/İFADE) MİNİMUM DEĞERİ ALMAK İÇİN
	MAX(EXPRESSİON/İFADE) MAXİMUM DEĞERİ ALMAK İÇİN
	COUNT(EXPRESSİON/İFADE) İFADENİN KAÇ ADET BULUNDUĞUNU BULMAK İÇİN ÖRN: BELİRLİ Bİ KOLONDA KAYIT VAR AMA KAÇ ADET OLDUĞUNU BİLMİYORSUNUZ BUNUN DEĞERİNİ VERİR
																														SELECT COUNT(NAME) FROM USERS
																														856 ÇIKTISINI VERİR
	SUM(EXPRESSİON/İFADE) BİR KOLONDAKİ DEĞERLERİ TOPLAR 
	AVG(EXPRESSİON/İFADE) BİR KOLONDAKİ DEĞERLERİN ORTALAMASINI VERİR
*/
SELECT 
	MIN(AMOUNT) AS MIN_AMOUNT,
	MAX(AMOUNT) AS MAX_AMOUNT,
	COUNT(AMOUNT) AS COUNT_AMOUNT,
	SUM(AMOUNT) AS SUM_AMOUNT,
	AVG(AMOUNT) AS AVG_AMOUNT 
FROM SALES

SELECT 
	MIN(TOTALPRICE) AS MIN_TOTALPRICE,
	MAX(TOTALPRICE) AS MAX_TOTALPRICE,
	COUNT(TOTALPRICE) AS COUNT_TOTALPRICE,
	SUM(TOTALPRICE) AS SUM_TOTALPRICE,
	AVG(TOTALPRICE) AS AVG_TOTALPRICE 
FROM SALES

SELECT 
	MIN(TOTALPRICE) AS MIN_TOTALPRICE,
	MAX(TOTALPRICE) AS MAX_TOTALPRICE,
	COUNT(TOTALPRICE) AS COUNT_TOTALPRICE,
	SUM(TOTALPRICE) AS SUM_TOTALPRICE,
	AVG(TOTALPRICE) AS AVG_TOTALPRICE 
FROM SALES WHERE (CITY='ADANA')

SELECT 
	MIN(TOTALPRICE) AS MIN_TOTALPRICE,
	MAX(TOTALPRICE) AS MAX_TOTALPRICE,
	COUNT(TOTALPRICE) AS COUNT_TOTALPRICE,
	SUM(TOTALPRICE) AS SUM_TOTALPRICE,
	AVG(TOTALPRICE) AS AVG_TOTALPRICE 
FROM SALES WHERE (CITY='ANKARA')

SELECT CITY,
	MIN(TOTALPRICE) AS MIN_TOTALPRICE,
	MAX(TOTALPRICE) AS MAX_TOTALPRICE,
	COUNT(TOTALPRICE) AS COUNT_TOTALPRICE,
	SUM(TOTALPRICE) AS SUM_TOTALPRICE,
	AVG(TOTALPRICE) AS AVG_TOTALPRICE 
FROM SALES GROUP BY CITY ORDER BY CITY

----------------------------------------------------------------------------------------------------------------------------------------

SELECT CITY,
	SUM(TOTALPRICE) AS DESC_TOTALPRICE
FROM SALES
GROUP BY CITY 
ORDER BY (SUM(TOTALPRICE)) DESC

UPDATE SALES
	SET DATE2= CONVERT(DATE,DATE_)

SELECT 
	DATE2,
	CITY,
	SUM(TOTALPRICE)
FROM SALES WHERE(DATE2='2019-01-01')
	GROUP BY DATE2,CITY 
	ORDER BY DATE2,SUM(TOTALPRICE) DESC

UPDATE SALES
	SET MONTHNAME_='12.ARALIK' WHERE (DATEPART(MONTH,DATE2)=12)

SELECT MONTHNAME_ FROM SALES

SELECT 
	MONTHNAME_,
	CITY,
	SUM(TOTALPRICE) AS TOTALPRICE 
FROM SALES
	GROUP BY CITY,MONTHNAME_ 
	ORDER BY CITY,MONTHNAME_ 


SELECT 
	MONTHNAME_,
	CITY,
	SUM(TOTALPRICE) AS TOTALPRICE 
FROM SALES WHERE(CITY='ADANA')
	GROUP BY CITY,MONTHNAME_ 
	ORDER BY CITY,MONTHNAME_ 


SELECT 
	CITY,
	MONTHNAME_,
	SUM(TOTALPRICE) AS TOTALPRICE 
FROM SALES
	GROUP BY CITY,MONTHNAME_ 
	ORDER BY MONTHNAME_ ,CITY

SELECT 
	CITY,
	MONTHNAME_,
	SUM(TOTALPRICE) AS TOTALPRICE 
FROM SALES WHERE(CITY='ADANA')
	GROUP BY CITY,MONTHNAME_ 
	ORDER BY CITY,MONTHNAME_ 

----------------------------------------------------------------------------------------------------------------------------------------
-- ÖRNEK RANDOM DATA SORGUSU --
DECLARE @I AS INT=1
DECLARE @ITEMID AS INT
DECLARE @DATE AS DATETIME
DECLARE @CUSTOMERID AS INT
DECLARE @CUSTOMERNAME AS VARCHAR(100)
DECLARE @CUSTOMERBIRTHDATE AS DATE
DECLARE @CUSTOMERGENDER AS VARCHAR(10)
DECLARE @DISTRICT AS VARCHAR(100)
DECLARE @REGION AS VARCHAR(100)
DECLARE @AMOUNT AS INT
DECLARE @ITEMCOUNT AS INT
DECLARE @CITY AS VARCHAR(100)
DECLARE @PRICEFACTOR AS FLOAT=1
DECLARE @HOUR INT
DECLARE @MINUTE INT
DECLARE @SECOND INT
DECLARE @BRANCHID AS INT
DECLARE @BRANCH AS VARCHAR(100)
DECLARE @RAND AS INT 
WHILE @I<=50000 -- BURAYA YAZDIĞINIZ DEĞER KADAR VERİ ÜRETİR
BEGIN
SET @HOUR=RAND()*22
IF  @HOUR<8 
	SET @HOUR=8
SET @MINUTE=RAND()*60
	SET @SECOND=RAND()*60
SET @RAND=RAND()*10000
	SELECT @CITY=CITYNAME,@REGION=REGION FROM CITIES WHERE @RAND BETWEEN RANDOMBEG AND RANDOMEND

	SELECT top 1 @CUSTOMERID=ID,@CUSTOMERNAME=NAMESURNAME,@CUSTOMERBIRTHDATE=BIRTHDATE,
		@DISTRICT=TOWN,@CUSTOMERGENDER=GENDER
	FROM DBO.CUSTOMERS WHERE CITY=@CITY    ORDER BY NEWID()

	SET @ITEMCOUNT=RAND()*9
	DECLARE @K AS INT=0
	WHILE @K<=@ITEMCOUNT
	BEGIN
		SET @RAND=RAND()*365
		SET @DATE=DATEADD(DAY,@RAND,'20190101')
		SET @DATE=DATEADD(HOUR,@HOUR,@DATE)
		SET @DATE=DATEADD(MINUTE,@MINUTE,@DATE)
		SET @DATE=DATEADD(SECOND ,@SECOND,@DATE)
		SET @AMOUNT=(RAND()*10)+1
		SET @RAND=RAND()*10
	
		IF @RAND BETWEEN 0 AND 5 
			SET @PRICEFACTOR=1
		IF @RAND=6 
			SET @PRICEFACTOR=0.8
		IF @RAND=7 
			SET @PRICEFACTOR=0.9
		IF @RAND=8
			SET @PRICEFACTOR=1.1
		IF @RAND=9 
			SET @PRICEFACTOR=1.2
		IF @RAND=10 
			SET @PRICEFACTOR=1.4
		SET @RAND =RAND()*28000
 
		INSERT INTO SALES (FICHENO,DATE_,ITEMCODE,ITEMNAME,BRAND,CATEGORY1,CATEGORY2,CATEGORY3,CATEGORY4,
		AMOUNT,PRICE,TOTALPRICE,CUSTOMERCODE,CUSTOMERNAME,CUSTOMERBIRHTDATE,CUSTOMERGENDER,
		BRANCH,CITY,DISTRICT,REGION)
		SELECT TOP 1 
		REPLICATE('0',10-LEN(@I))+CONVERT(VARCHAR,@I),@DATE,ITEMCODE,ITEMNAME,BRAND,CATEGORY1,CATEGORY2,CATEGORY3,CATEGORY4,
		@AMOUNT,SALEPRICE,@AMOUNT*SALEPRICE*@PRICEFACTOR,@CUSTOMERID,@CUSTOMERNAME,@CUSTOMERBIRTHDATE,@CUSTOMERGENDER,
		@CITY,@CITY,@DISTRICT,@REGION
		FROM ITEMS WHERE SALEPRICE>0.1 AND ID>=@RAND ORDER BY ID 

SET @K=@K+1
END
 
SET @I=@I+1
END

 


----------------------------------------------------------------------------------------------------------------------------------------
-- RANDOM DATA --

--TRUNCATE TABLE ORDERS
--TRUNCATE TABLE ORDERDETAILS
--TRUNCATE TABLE INVOICES
--TRUNCATE TABLE INVOICEDETAILS
--TRUNCATE TABLE PAYMENTS
 

DECLARE @I AS INT=0
DECLARE @ITEMCOUNT AS INT
DECLARE @ADDRESSID AS INT 
DECLARE @ORDERID AS INT
DECLARE @ITEMID AS INT
DECLARE @USERID AS INT
DECLARE @DATE AS DATETIME
DECLARE @TOTALPRICE AS FLOAT
DECLARE @PRICE AS FLOAT
DECLARE @AMOUNT AS INT
DECLARE @INVOICEID AS INT

WHILE @I<10000
BEGIN
SELECT TOP 1  @USERID=ID FROM ETRADE4.DBO.USERS ORDER BY NEWID()
SELECT TOP 1 @ADDRESSID=ID FROM ADDRESS WHERE USERID=@USERID  ORDER BY NEWID()
WHILE @ADDRESSID IS NULL
BEGIN
	SELECT TOP 1  @USERID=ID FROM ETRADE4.DBO.USERS ORDER BY NEWID()
	SELECT TOP 1 @ADDRESSID=ID FROM ADDRESS WHERE USERID=@USERID  ORDER BY NEWID()
END

SET @DATE=DATEADD(DAY,RAND()*450,'20190101')
SET @DATE=DATEADD(HOUR,RAND()*24,@DATE) 
SET @DATE=DATEADD(MINUTE,RAND()*60,@DATE) 
SET @DATE=DATEADD(SECOND,RAND()*60,@DATE) 
SET @ITEMCOUNT=1+(RAND()*10)
DECLARE @K AS INT=0
INSERT INTO ORDERS(USERID,DATE_,TOTALPRICE,STATUS_,ADDRESSID)
	VALUES (@USERID,@DATE,0,0,@ADDRESSID)
SET @ORDERID=@@IDENTITY

WHILE @K<@ITEMCOUNT
BEGIN
	SELECT TOP 1  @ITEMID=ID,@PRICE=UNITPRICE*(1+(RAND()*0.2)),@AMOUNT=1+(RAND()*10) FROM ITEMS WHERE UNITPRICE>0 ORDER BY NEWID()
	INSERT INTO ORDERDETAILS (ORDERID,ITEMID,AMOUNT,UNITPRICE,LINETOTAL)
	VALUES(@ORDERID,@ITEMID,@AMOUNT,@PRICE,@PRICE*@AMOUNT)
	
---------------------------------------------------------------------------------
-- PROCEDURE --
CREATE PROCEDURE BOL
AS
DECLARE 
	@SAYI1 FLOAT = 20,
	@SAYI2 FLOAT = 38.8,
	@SONUC FLOAT,
	@ISLEM CHAR ='/'

IF @ISLEM = '/'
	BEGIN
	SET @SONUC = @SAYI1 @ISLEM @SAYI2
	SELECT @SONUC
	END
GO

EXEC BOL
---------------------------------------------------------------------------------
SET @K=@K+1
END --@K
--UPDATE ORDERS SET TOTALPRICE=ROUND((SELECT SUM(LINETOTAL) FROM ORDERDETAILS WHERE ORDERID=@ORDERID),2)
--WHERE ID=@ORDERID

INSERT INTO PAYMENTS
(ORDERID,PAYMENTTYPE,DATE_,ISOK,APPROVECODE,PAYMENTTOTAL)

SELECT ID,1+(RAND()*2),DATEADD(SECOND,2,@DATE),1,'APPRV'+REPLICATE('0',10-LEN(@ORDERID))+CONVERT(VARCHAR,@ORDERID),TOTALPRICE
FROM ORDERS WHERE ID=@ORDERID

--UPDATE ORDERS SET STATUS_=1 WHERE ID=@ORDERID

	INSERT INTO INVOICES(ORDERID,DATE_,ADDRESSID,CARGOFICHENO,TOTALPRICE)
	SELECT   ID,DATEADD(MINUTE,RAND()*60,DATEADD(HOUR,10+(RAND()*24),@DATE)) AS DATE_,
	ADDRESSID,'CRGF'+REPLICATE('0',10-LEN(@ORDERID))+CONVERT(VARCHAR,@ORDERID) AS CARGOFICHENO,TOTALPRICE
	 FROM ORDERS WHERE ID=@ORDERID
 SET @INVOICEID=@@IDENTITY
	 INSERT INTO INVOICEDETAILS
	 (INVOICEID,ORDERDETAILID,ITEMID,AMOUNT,UNITPRICE,LINETOTAL)
	 SELECT @INVOICEID,ID,ITEMID,AMOUNT,UNITPRICE,LINETOTAL
	 FROM ORDERDETAILS WHERE ORDERID=@ORDERID

--UPDATE ORDERS SET STATUS_=2 WHERE ID=@ORDERID
SET @I=@I+1
END-- @I
SELECT * FROM ORDERS
SELECT * FROM ORDERDETAILS
SELECT * FROM PAYMENTS
SELECT * FROM INVOICES
SELECT * FROM INVOICEDETAILS



----------------------------------------------------------------------------------------------------------------------------------------
SELECT 
	CATEGORY1,
	CATEGORY2,
	CATEGORY3,
	CATEGORY4, 
	SUM(TOTALPRICE) AS TOTALPRICE,
	COUNT(*) AS ROWCOUNT_,
	SUM(AMOUNT) AS TOTALAMAOUNT
FROM SALES 
	GROUP BY 
		CATEGORY1,
		CATEGORY2,
		CATEGORY3,
		CATEGORY4 
	ORDER BY 
		CATEGORY1,
		CATEGORY2,
		CATEGORY3,
		CATEGORY4

SELECT 
	FICHENO,
	COUNT(*) AS COUNT_,
	CITY AS CITY_
FROM SALES 
	WHERE (MONTHNAME_='01.OCAK' AND CITY='ADANA')
	GROUP BY FICHENO,CITY


SELECT 
	FICHENO,
	COUNT(*) AS COUNT_,
	CITY AS CITY_
FROM SALES 
	WHERE (MONTHNAME_='01.OCAK')
	GROUP BY FICHENO,CITY
	ORDER BY CITY

SELECT 
	CITY AS SEHIR,
	COUNT(DISTINCT FICHENO) AS OCAK_AYI_SATIS,
	COUNT(*) AS TOPLAM_FATURA
	
FROM SALES 
	WHERE (MONTHNAME_='01.OCAK')
	GROUP BY CITY
	ORDER BY CITY


SELECT 
	CITY,
	SUM(TOTALPRICE) 
FROM SALES 
	GROUP BY CITY 
	HAVING SUM(TOTALPRICE)<40000
	ORDER BY SUM(TOTALPRICE) DESC


SELECT  COUNT(CITY) - COUNT(DISTINCT CITY)  FROM STATION 


SELECT * FROM USERS
-- ID İLE ADRESLERİ ÇEKME -- 
SELECT USERS.*,ADDRESS_.ADDRESSTEXT FROM 
USERS,ADDRESS_ WHERE USERS.ID=ADDRESS_.USERID AND USERS.ID=4

SELECT 
	U.NAMESURNAME, U.EMAIL,U.GENDER,U.BIRTHDATE
	,A.ADDRESSTEXT
	FROM USERS AS U,ADDRESS_ AS A
WHERE (U.ID=A.USERID AND U.ID=4)

SELECT 
	U.NAMESURNAME, U.EMAIL,U.GENDER,U.BIRTHDATE
	,A.ADDRESSTEXT
	,A.POSTALCODE
	,C.COUNTRY
	,CT.CITY
	,T.TOWN
	,D.DISTRICT
	FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
WHERE (U.ID=A.USERID AND C.ID=A.COUNTRYID AND CT.ID=A.CITYID AND T.ID=A.TOWNID AND  D.ID=A.DISTRICTID AND U.ID=4 )


SELECT 
	U.NAMESURNAME, U.EMAIL,U.GENDER,U.BIRTHDATE
	,A.ADDRESSTEXT
	,A.POSTALCODE
	,C.COUNTRY
	,CT.CITY
	,T.TOWN
	,D.DISTRICT
	FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
WHERE (U.ID=A.USERID AND C.ID=A.COUNTRYID AND CT.ID=A.CITYID AND T.ID=A.TOWNID AND  D.ID=A.DISTRICTID )
ORDER BY NAMESURNAME



SELECT 
	U.NAMESURNAME, U.EMAIL,U.GENDER,U.BIRTHDATE
	,A.ADDRESSTEXT
	,A.POSTALCODE
	,C.COUNTRY
	,CT.CITY
	,T.TOWN
	,D.DISTRICT
	FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
WHERE (
	U.ID=A.USERID AND 
	C.ID=A.COUNTRYID AND 
	CT.ID=A.CITYID AND 
	T.ID=A.TOWNID AND  
	D.ID=A.DISTRICTID AND
	CT.CITY LIKE 'BURSA'
						)
ORDER BY NAMESURNAME



SELECT 
	COUNT(DISTINCT U.ID)
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	

SELECT 
	U.ID
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY U.ID

SELECT 
	U.NAMESURNAME, COUNT(A.ID) AS ADDRESS_COUNT
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY U.NAMESURNAME


SELECT 
	U.NAMESURNAME, COUNT(DISTINCT C.COUNTRY) AS COUNTRY_COUNT
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY U.NAMESURNAME

SELECT 
	U.NAMESURNAME, COUNT(DISTINCT CT.ID) AS CITY_COUNT
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY U.NAMESURNAME


SELECT 
	U.NAMESURNAME, COUNT(DISTINCT CT.ID) AS CITY_COUNT
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY U.NAMESURNAME
	HAVING COUNT(A.ID)>2


SELECT 
	CT.CITY
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY CT.CITY



SELECT 
	CT.CITY,COUNT(U.ID) AS USER_COUNT
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY CT.CITY



SELECT 
	CT.CITY,COUNT(U.ID) AS USER_COUNT,COUNT(DISTINCT D.DISTRICT) AS DISTRICT_COUNT
FROM USERS AS U,ADDRESS_ AS A, COUNTRIES C,CITIES CT,TOWNS T,DISTRICTS D
	WHERE (
		U.ID=A.USERID AND 
		C.ID=A.COUNTRYID AND 
		CT.ID=A.CITYID AND 
		T.ID=A.TOWNID AND  
		D.ID=A.DISTRICTID)
	GROUP BY CT.CITY
----------------------------------------------------------------------------------------------------------------------------------------


SELECT U.NAMESURNAME,A.ADDRESSTEXT,C.COUNTRY,CT.CITY,T.TOWN,D.DISTRICT
	FROM USERS U
	JOIN ADDRESS_ A ON A.USERID = U.ID
	JOIN COUNTRIES C ON C.ID=A.COUNTRYID
	JOIN CITIES CT ON CT.ID=A.CITYID
	JOIN TOWNS T ON T.ID=A.TOWNID
	JOIN DISTRICTS D ON D.ID = A.DISTRICTID

SELECT

FROM USERS U LEFT JOIN ADDRESS_ A ON U.ID=A.USERID
------------------------------------------------------------------------------------
 SELECT 
	U.USERNAME_ AS USERNAME,
	U.NAMESURNAME AS NAME_SURNAME,
	CT.CITY AS CITY,
	T.TOWN AS TOWN,
	D.DISTRICT AS DISTRICT,
	A.ADDRESSTEXT AS ADRESS_,
	O.ID AS ORDERID,
	O.DATE_ AS ORDERDATE_,
	O.TOTALPRICE AS TOTALPRICE,
	P.DATE_ AS PAYMENT_DATE,
	P.APPROVECODE AS APPROVECODE,
	I.DATE_ AS FICHE_DATE,
	I.CARGOFICHENO AS CARGO_FICHENO
 FROM (ORDERS O 
	INNER JOIN USERS U ON U.ID=O.USERID
	INNER JOIN ADDRESS A ON A.ID=O.ADDRESSID
	INNER JOIN CITIES CT ON CT.ID=A.CITYID
	INNER JOIN TOWNS T ON T.ID=A.TOWNID
	INNER JOIN DISTRICTS D ON D.ID=A.DISTRICTID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID
	INNER JOIN INVOICES I ON I.ORDERID=O.ID)



 
SELECT 
	U.USERNAME_ AS USERNAME,
	U.NAMESURNAME AS NAME_SURNAME,
	CT.CITY AS CITY,
	T.TOWN AS TOWN,
	D.DISTRICT AS DISTRICT,
	A.ADDRESSTEXT AS ADRESS_,
	O.ID AS ORDERID,
	O.DATE_ AS ORDERDATE_,
	O.TOTALPRICE AS TOTALPRICE,
	P.DATE_ AS PAYMENT_DATE,
	P.APPROVECODE AS APPROVECODE,
	I.DATE_ AS FICHE_DATE,
	I.CARGOFICHENO AS CARGO_FICHENO
 FROM (ORDERS O 
	INNER JOIN USERS U ON U.ID=O.USERID
	INNER JOIN ADDRESS A ON A.ID=O.ADDRESSID
	INNER JOIN CITIES CT ON CT.ID=A.CITYID
	INNER JOIN TOWNS T ON T.ID=A.TOWNID
	INNER JOIN DISTRICTS D ON D.ID=A.DISTRICTID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID
	INNER JOIN INVOICES I ON I.ORDERID=O.ID)
WHERE (U.USERNAME_='A_TOLU')


 SELECT 
	U.USERNAME_ AS USERNAME,
	U.NAMESURNAME AS NAME_SURNAME,
	CT.CITY AS CITY,
	T.TOWN AS TOWN,
	D.DISTRICT AS DISTRICT,
	A.ADDRESSTEXT AS ADRESS_,
	O.ID AS ORDERID,
	O.DATE_ AS ORDERDATE_,
	O.TOTALPRICE AS TOTALPRICE,
	P.DATE_ AS PAYMENT_DATE,
	P.APPROVECODE AS APPROVECODE,
	I.DATE_ AS FICHE_DATE,
	I.CARGOFICHENO AS CARGO_FICHENO,
	ITM.ITEMCODE AS ITEMCODE,
	ITM.ITEMNAME AS ITEMNAME,
	OD.AMOUNT AS AMOUNT,
	OD.UNITPRICE AS UNITPRICE,
	OD.LINETOTAL AS LINE_TOTAL
 FROM (ORDERS O 
	INNER JOIN USERS U ON U.ID=O.USERID
	INNER JOIN ADDRESS A ON A.ID=O.ADDRESSID
	INNER JOIN CITIES CT ON CT.ID=A.CITYID
	INNER JOIN TOWNS T ON T.ID=A.TOWNID
	INNER JOIN DISTRICTS D ON D.ID=A.DISTRICTID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID
	INNER JOIN INVOICES I ON I.ORDERID=O.ID)
	INNER JOIN ORDERDETAILS OD ON OD.ORDERID=O.ID
	INNER JOIN ITEMS ITM ON ITM.ID=OD.ITEMID
WHERE (U.USERNAME_='C_SANDIKCI')
--(O.ID=13119)


SELECT 
	CT.CITY AS CITY_NAME,
	SUM(OD.LINETOTAL) AS SUM_TOTALPRICE,
	SUM(OD.AMOUNT) AS SUM_AMOUNT,
	COUNT(OD.ID) TOTAL_ORDER
FROM (ORDERS O 
	INNER JOIN ADDRESS A ON A.ID=O.ADDRESSID
	INNER JOIN CITIES CT ON CT.ID=A.CITYID
	INNER JOIN ORDERDETAILS OD ON OD.ORDERID=O.ID)
GROUP BY CT.CITY
ORDER BY CT.CITY


SELECT 
	CT.CITY AS CITY_NAME,
	SUM(OD.LINETOTAL) AS SUM_TOTALPRICE,
	SUM(OD.AMOUNT) AS SUM_AMOUNT,
	COUNT(OD.ID) TOTAL_ORDER
FROM (ORDERS O 
	INNER JOIN ADDRESS A ON A.ID=O.ADDRESSID
	INNER JOIN CITIES CT ON CT.ID=A.CITYID
	INNER JOIN ORDERDETAILS OD ON OD.ORDERID=O.ID)
GROUP BY CT.CITY
ORDER BY SUM(OD.LINETOTAL) DESC


SELECT 
	ITM.CATEGORY1 AS CATEGORY_1,
	ITM.CATEGORY2 AS CATEGORY_2,
	SUM(OD.LINETOTAL) AS SUM_TOTALPRICE,
	SUM(OD.AMOUNT) AS SUM_AMOUNT,
	COUNT(OD.ID) TOTAL_ORDER
FROM (ORDERS O 
	INNER JOIN ORDERDETAILS OD ON OD.ORDERID=O.ID
	INNER JOIN ITEMS ITM ON ITM.ID=OD.ITEMID)
WHERE ITM.CATEGORY1='EV'
GROUP BY ITM.CATEGORY1,ITM.CATEGORY2
ORDER BY 3 DESC



SELECT 
	CONVERT(DATE,O.DATE_) AS DATE_,
	SUM(OD.LINETOTAL) AS TOTALORDER_PRICE,
	SUM(OD.AMOUNT) AS TOTALORDER_AMOUNT,
	COUNT(OD.ID) AS TOTALORDER_AMOUNT

FROM (ORDERS O 
	INNER JOIN ORDERDETAILS OD ON OD.ORDERID=O.ID)
GROUP BY CONVERT(DATE,O.DATE_)
ORDER BY CONVERT(DATE,O.DATE_)



SELECT 
	DATEPART(YEAR,O.DATE_) AS YEAR_,
	DATEPART(MONTH,O.DATE_) AS MONTH_,
	CASE
		WHEN DATEPART(MONTH,O.DATE_)=1 THEN 'January'
		WHEN DATEPART(MONTH,O.DATE_)=2 THEN 'February'
		WHEN DATEPART(MONTH,O.DATE_)=3 THEN 'March'
		WHEN DATEPART(MONTH,O.DATE_)=4 THEN 'April'
		WHEN DATEPART(MONTH,O.DATE_)=5 THEN 'May'
		WHEN DATEPART(MONTH,O.DATE_)=6 THEN 'June'
		WHEN DATEPART(MONTH,O.DATE_)=7 THEN 'July'
		WHEN DATEPART(MONTH,O.DATE_)=8 THEN 'August '
		WHEN DATEPART(MONTH,O.DATE_)=9 THEN 'September'
		WHEN DATEPART(MONTH,O.DATE_)=10 THEN 'October'
		WHEN DATEPART(MONTH,O.DATE_)=11 THEN 'November'
		WHEN DATEPART(MONTH,O.DATE_)=12 THEN 'December'
	END AS MONTH_NAME,	
	SUM(OD.LINETOTAL) AS TOTALORDER_PRICE,
	SUM(OD.AMOUNT) AS TOTALORDER_AMOUNT,
	COUNT(OD.ID) AS TOTALORDER_AMOUNT

FROM (ORDERS O 
	INNER JOIN ORDERDETAILS OD ON OD.ORDERID=O.ID)

GROUP BY DATEPART(MONTH,O.DATE_),DATEPART(YEAR,O.DATE_)
ORDER BY DATEPART(MONTH,O.DATE_),DATEPART(YEAR,O.DATE_)





SELECT 
	DATEPART(YEAR,DATE_) AS YEAR_,
	DATEPART(MONTH,DATE_) AS MONTH_,
	CASE
		WHEN (PAYMENTTYPE)=1 THEN 'CREDIT CARD'
		WHEN (PAYMENTTYPE)=2 THEN 'BANK TRANSFER'
	END AS PAYMENT_TYPE_DESCRIPTION,
	SUM(PAYMENTTOTAL) AS SUM_PAYMENT
FROM PAYMENTS
GROUP BY DATEPART(MONTH,DATE_),PAYMENTTYPE,DATEPART(YEAR,DATE_)
ORDER BY DATEPART(YEAR,DATE_),DATEPART(MONTH,DATE_)




SELECT 
	MIN(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS EN_KISA_TESLIMAT_SAAT,
	MAX(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS EN_UZUN_TESLIMAT_SAAT,
	AVG(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS TESLIMAT_SURESI_ORT_SAAT
FROM ORDERS O 

	INNER JOIN INVOICES I ON I.ORDERID=O.ID


SELECT 
	U.ID AS USERID,
	U.NAMESURNAME AS USER_NS,
	AVG(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS ORTALAMA_TESLIMAT_SURESI
FROM ORDERS O 
	INNER JOIN USERS U ON U.ID=O.USERID
	INNER JOIN INVOICES I ON I.ORDERID=O.ID
	GROUP BY U.ID,U.NAMESURNAME
	HAVING AVG(DATEDIFF(HOUR,O.DATE_,I.DATE_))>23
	ORDER BY 3 DESC




SELECT 
	U.ID AS USERID,
	U.NAMESURNAME AS USER_NS,
	AVG(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS ORTALAMA_TESLIMAT_SURESI,
	MIN(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS MIN_TESLIMAT_SURESI,
	MAX(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS MAX_TESLIMAT_SURESI,
	SUM(O.TOTALPRICE) AS TOPLAM_SIPARIS_TUTARI,
	COUNT(O.ID) AS SIPARIS_SAYISI
FROM ORDERS O 
	INNER JOIN USERS U ON U.ID=O.USERID
	INNER JOIN INVOICES I ON I.ORDERID=O.ID
	GROUP BY U.ID,U.NAMESURNAME
	HAVING AVG(DATEDIFF(HOUR,O.DATE_,I.DATE_))>23
	ORDER BY 6 DESC 


SELECT 
	DATEPART(YEAR,O.DATE_) AS YIL,
	DATEPART(MONTH,O.DATE_) AS AY,
	AVG(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS ORTALAMA_TESLIMAT_SURESI,
	MIN(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS MIN_TESLIMAT_SURESI,
	MAX(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS MAX_TESLIMAT_SURESI,
	SUM(O.TOTALPRICE) AS TOPLAM_SIPARIS_TUTARI,
	COUNT(O.ID) AS SIPARIS_SAYISI
FROM ORDERS O 
	INNER JOIN INVOICES I ON I.ORDERID=O.ID
	GROUP BY DATEPART(YEAR,O.DATE_),DATEPART(MONTH,O.DATE_)
	ORDER BY 1,2
	



SELECT 
	CT.CITY AS SEHIR,
	AVG(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS ORTALAMA_TESLIMAT_SURESI,
	MIN(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS MIN_TESLIMAT_SURESI,
	MAX(DATEDIFF(HOUR,O.DATE_,I.DATE_)) AS MAX_TESLIMAT_SURESI,
	SUM(O.TOTALPRICE) AS TOPLAM_SIPARIS_TUTARI,
	COUNT(O.ID) AS SIPARIS_SAYISI
FROM ORDERS O 
	INNER JOIN ADDRESS A ON A.ID=O.ADDRESSID
	INNER JOIN CITIES CT ON CT.ID=A.CITYID
	INNER JOIN INVOICES I ON I.ORDERID=O.ID
	GROUP BY CT.CITY
	ORDER BY 2 DESC


--------------------------------------------------------------------------

-- SUBQUERY --

SELECT
	ITM.ITEMCODE AS ITEM_CODE,
	ITM.ITEMNAME AS ITEM_NAME,
	(SELECT MIN(UNITPRICE) 
		FROM ORDERDETAILS 
		WHERE ITEMID=ITM.ID) AS MIN_PRICE,

	(SELECT MAX(UNITPRICE) 
		FROM ORDERDETAILS 
		WHERE ITEMID=ITM.ID) AS MAX_PRICE,

	(SELECT AVG(UNITPRICE) 
		FROM ORDERDETAILS 
		WHERE ITEMID=ITM.ID) AS AVG_PRICE,
	(SELECT SUM(AMOUNT) 
		FROM ORDERDETAILS 
		WHERE ITEMID=ITM.ID) AS SUM_AMOUNT,
	(SELECT SUM(LINETOTAL) 
		FROM ORDERDETAILS 
		WHERE ITEMID=ITM.ID) AS SUM_LINETOTAL
FROM 
	ITEMS ITM
ORDER BY 
	ITM.ITEMNAME

-----------------------------------------
CREATE PROCEDURE CUSTOMERR
	@CUSTOMER_EMAIL NVARCHAR(50)
	AS BEGIN
	DECLARE 
		@CUSTOMERCODE NVARCHAR(50),
		@NEW_CUSTOMER_CODE NVARCHAR(50)
	SET @CUSTOMERCODE = ISNULL((SELECT TOP(1) CUSTOMERCODE FROM CUSTOMER WHERE CUSTOMER_EMAIL = @CUSTOMER_EMAIL),0)
	SET @NEW_CUSTOMER_CODE = (SELECT 'INT.100' + REPLACE(STR((MAX(SUBSTRING(CUSTOMERCODE,9,13))+1),5,0),' ',0) FROM CUSTOMER WHERE CUSTOMERCODE LIKE '-')
IF (@CUSTOMERCODE = 0)
	BEGIN
		SELECT @NEW_CUSTOMER_CODE AS CARI_KOD
	END
ELSE IF (@CUSTOMERCODE <> 0)
	BEGIN
		@CUSTOMERCODE AS CARI_KOD
	END

exec CUSTOMERR 'MEMET@MEMET.COM'
-------------------------------------------

SELECT SUBSTRING('QWEASDZXCFGH',4,3)

SELECT SUBSTRING(REPLACE('KELIME CUMLE PARAGRAF',' ',''),1,19)

SELECT * FROM USERS WHERE (USERNAME_ LIKE 'A%')

SELECT LEN(USERNAME_) AS LEN_,USERNAME_ AS USER_NAME_ FROM USERS

SELECT * FROM USERS WHERE (SUBSTRING(USERNAME_,1,1) = 'A')

SELECT CHARINDEX('P','KELIME CUMLE PARAGRAF')

SELECT CONCAT('KELIME','CUMLE','PARAGRAF')

SELECT CONCAT_WS(' ','KELIME','CUMLE','PARAGRAF')

SELECT FORMAT(GETDATE(),'d','TR-TR')

SELECT LEFT('KELIME CUMLE PARAGRAF',6)

SELECT RIGHT('KELIME CUMLE PARAGRAF',8)

SELECT TRIM(' KELIME CUMLE PARAGRAF ')

SELECT LTRIM(' KELIME CUMLE PARAGRAF ')

SELECT RTRIM(' KELIME CUMLE PARAGRAF ')

SELECT LOWER('KELIME CUMLE PARAGRAF')

SELECT UPPER('kelime cumle paragraf')

SELECT REVERSE('KELIME CUMLE PARAGRAF')

SELECT REPLICATE('1',10)

SELECT REPLACE('KELIME PARAGRAF CUMLE','PARAGRAF CUMLE','CUMLE PARAGRAF')

DECLARE 
	@CUMLE VARCHAR(MAX)='API teriminin anlamı ilk başta, uygulama programları (AP - Application Programs) olarak bilinen,
		yalnızca son kullanıcıya dönük programlar için bir arayüz tanımladı.
		Bugün, API terimi yalnızca uygulama programlama arayüzlerini değil, 
		aynı zamanda birçok yazılım türünü ve hatta donanım arayüzlerini de tanımlamaktadır.API fikri, terimden çok daha eskidir.
		İngiliz bilgisayar bilimcileri Wilkes ve Wheeler, 1940larda EDSAC (Electronic Delay Storage Automatic Calculator) 
		bilgisayarı için modüler yazılım kitaplıkları üzerinde çalıştı. Joshua Bloch, Wilkes ve Wheelerın APIyi 
		"son zamanlarda icat ettiklerini", çünkü icat edilmekten çok keşfedilen bir kavram olduğundan bahseder. 
		"Uygulama Programı Arayüzü (Application Program Interface" terimi ilk olarak 1968de bir A
		FIPS (American Federation of Information Processing Societies) konferansında sunulan uzak bilgisayar 
		grafikleri için veri yapıları ve teknikleri adlı bir makalede kaydedilmiştir.
		Terim, veri tabanları alanına C.J. Date tarafından "The Relational and Network Approaches: 
		Comparison of the Application Programming Interface" adlı 1974 tarihli bir makalede tanıtıldı.
		Bir API, veritabanı yönetim sistemleri için ANSI (American National Standards Institute)/SPARC 
		(Standards Planning And Requirements Committee) yapısının bir parçası haline geldi. Bu yapı,
		uygulama programlama arayüzünü sorgu arayüzü gibi diğer arayüzlerden ayrı olarak ele aldı.
		1970lerdeki veritabanı uzmanları, bu farklı arayüzlerin birleştirilebileceğini gözlemlemişlerdir.
		Bu gözlem, yalnızca uygulama programlamayı değil, her tür programlamayı destekleyen APIlere yol açar.
		1990a gelindiğinde API, teknoloji uzmanı Carl Malamud tarafından basitçe "bir programcıya belirli 
		görevleri yerine getirmek için sunulan bir dizi hizmet" olarak tanımlandı.'
PRINT @CUMLE
SELECT LEN(@CUMLE)
SET @CUMLE=REPLACE(@CUMLE,'bilgisayar','')
SELECT LEN(@CUMLE)

------------------------------------------------------------

CREATE VIEW VWORDERS
AS

SELECT
	U.USERNAME_  USERNAME,
	U.NAMESURNAME  NAME_SURNAME,
	CT.CITY  CITY,
	T.TOWN  TOWN,
	A.ADDRESSTEXT  ADRESS_,
	O.ID  ORDERID,
	O.DATE_  ORDERDATE_,
	O.TOTALPRICE  TOTALPRICE,
	P.DATE_  PAYMENT_DATE,
	P.APPROVECODE  APPROVECODE,
	ITM.ITEMCODE  ITEMCODE,
	ITM.ITEMNAME  ITEMNAME,
	OD.AMOUNT  AMOUNT,
	OD.UNITPRICE  UNITPRICE,
	OD.LINETOTAL  LINE_TOTAL
FROM ORDERDETAILS OD
	INNER JOIN ORDERS O ON OD.ORDERID = O.ID
	INNER JOIN ITEMS ITM ON ITM.ID = OD.ITEMID
	INNER JOIN USERS U ON U.ID = O.USERID
	INNER JOIN ADDRESS A ON A.ID = O.ADDRESSID
	INNER JOIN COUNTRIES C ON C.ID = A.COUNTRYID
	INNER JOIN CITIES CT ON CT.ID = A.CITYID
	INNER JOIN TOWNS T ON T.ID = A.TOWNID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID

SELECT * FROM VWORDERS


SELECT
	DATEPART(YEAR,O.DATE_) YEAR_,
CASE
		WHEN DATEPART(MONTH,O.DATE_)=1 THEN 'January'
		WHEN DATEPART(MONTH,O.DATE_)=2 THEN 'February'
		WHEN DATEPART(MONTH,O.DATE_)=3 THEN 'March'
		WHEN DATEPART(MONTH,O.DATE_)=4 THEN 'April'
		WHEN DATEPART(MONTH,O.DATE_)=5 THEN 'May'
		WHEN DATEPART(MONTH,O.DATE_)=6 THEN 'June'
		WHEN DATEPART(MONTH,O.DATE_)=7 THEN 'July'
		WHEN DATEPART(MONTH,O.DATE_)=8 THEN 'August '
		WHEN DATEPART(MONTH,O.DATE_)=9 THEN 'September'
		WHEN DATEPART(MONTH,O.DATE_)=10 THEN 'October'
		WHEN DATEPART(MONTH,O.DATE_)=11 THEN 'November'
		WHEN DATEPART(MONTH,O.DATE_)=12 THEN 'December'
	END AS MONT_NAME,
	SUM(AMOUNT) SUM_AMOUNT,
	SUM(LINETOTAL) SUM_LINE,
	COUNT(OD.ID) PRODUCT_COUNT,
	COUNT(DISTINCT O.ID) CUSTOMER_COUNT

FROM ORDERDETAILS OD
	INNER JOIN ORDERS O ON OD.ORDERID = O.ID
	INNER JOIN ITEMS ITM ON ITM.ID = OD.ITEMID
	INNER JOIN USERS U ON U.ID = O.USERID
	INNER JOIN ADDRESS A ON A.ID = O.ADDRESSID
	INNER JOIN COUNTRIES C ON C.ID = A.COUNTRYID
	INNER JOIN CITIES CT ON CT.ID = A.CITYID
	INNER JOIN TOWNS T ON T.ID = A.TOWNID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID
GROUP BY 
	DATEPART(YEAR,O.DATE_),
	DATEPART(MONTH,O.DATE_)
ORDER BY
	DATEPART(YEAR,O.DATE_),
	DATEPART(MONTH,O.DATE_)
----------------------------------------------------
CREATE VIEW VW_AYLARA_GORE_GETIR
AS

SELECT
	DATEPART(YEAR,O.DATE_) YEAR_,
	DATEPART(MONTH,O.DATE_) MONTH_,
	SUM(AMOUNT) SUM_AMOUNT,
	SUM(LINETOTAL) SUM_LINE,
	COUNT(OD.ID) PRODUCT_COUNT,
	COUNT(DISTINCT O.ID) CUSTOMER_COUNT

FROM ORDERDETAILS OD
	INNER JOIN ORDERS O ON OD.ORDERID = O.ID
	INNER JOIN ITEMS ITM ON ITM.ID = OD.ITEMID
	INNER JOIN USERS U ON U.ID = O.USERID
	INNER JOIN ADDRESS A ON A.ID = O.ADDRESSID
	INNER JOIN COUNTRIES C ON C.ID = A.COUNTRYID
	INNER JOIN CITIES CT ON CT.ID = A.CITYID
	INNER JOIN TOWNS T ON T.ID = A.TOWNID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID
GROUP BY 
	DATEPART(YEAR,O.DATE_),
	DATEPART(MONTH,O.DATE_)
SELECT * FROM VW_AYLARA_GORE_GETIR


ALTER VIEW VW_AYLARA_GORE_GETIR
AS

SELECT
	DATEPART(YEAR,O.DATE_) YEAR_,
	CASE
		WHEN DATEPART(MONTH,O.DATE_)=1 THEN '01.January'
		WHEN DATEPART(MONTH,O.DATE_)=2 THEN '02.February'
		WHEN DATEPART(MONTH,O.DATE_)=3 THEN '03.March'
		WHEN DATEPART(MONTH,O.DATE_)=4 THEN '04.April'
		WHEN DATEPART(MONTH,O.DATE_)=5 THEN '05.May'
		WHEN DATEPART(MONTH,O.DATE_)=6 THEN '06.June'
		WHEN DATEPART(MONTH,O.DATE_)=7 THEN '07.July'
		WHEN DATEPART(MONTH,O.DATE_)=8 THEN '08.August '
		WHEN DATEPART(MONTH,O.DATE_)=9 THEN '09.September'
		WHEN DATEPART(MONTH,O.DATE_)=10 THEN '10.October'
		WHEN DATEPART(MONTH,O.DATE_)=11 THEN '11.November'
		WHEN DATEPART(MONTH,O.DATE_)=12 THEN '12.December'
	END AS MONT_NAME,
	SUM(AMOUNT) SUM_AMOUNT,
	SUM(LINETOTAL) SUM_LINE,
	COUNT(OD.ID) PRODUCT_COUNT,
	COUNT(DISTINCT O.ID) CUSTOMER_COUNT

FROM ORDERDETAILS OD
	INNER JOIN ORDERS O ON OD.ORDERID = O.ID
	INNER JOIN ITEMS ITM ON ITM.ID = OD.ITEMID
	INNER JOIN USERS U ON U.ID = O.USERID
	INNER JOIN ADDRESS A ON A.ID = O.ADDRESSID
	INNER JOIN COUNTRIES C ON C.ID = A.COUNTRYID
	INNER JOIN CITIES CT ON CT.ID = A.CITYID
	INNER JOIN TOWNS T ON T.ID = A.TOWNID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID
GROUP BY 
	DATEPART(YEAR,O.DATE_),
	DATEPART(MONTH,O.DATE_)



SELECT
	U.USERNAME_  USERNAME,
	U.NAMESURNAME  NAME_SURNAME,
	CT.CITY  CITY,
	T.TOWN  TOWN,
	A.ADDRESSTEXT  ADRESS_,
	O.ID  ORDERID,
	O.DATE_  ORDERDATE_,
	O.TOTALPRICE  TOTALPRICE,
	P.DATE_  PAYMENT_DATE,
	P.APPROVECODE  APPROVECODE,
	ITM.ITEMCODE  ITEMCODE,
	ITM.ITEMNAME  ITEMNAME,
	OD.AMOUNT  AMOUNT,
	OD.UNITPRICE  UNITPRICE,
	OD.LINETOTAL  LINE_TOTAL
FROM ORDERDETAILS OD
	INNER JOIN ORDERS O ON OD.ORDERID = O.ID
	INNER JOIN ITEMS ITM ON ITM.ID = OD.ITEMID
	INNER JOIN USERS U ON U.ID = O.USERID
	INNER JOIN ADDRESS A ON A.ID = O.ADDRESSID
	INNER JOIN COUNTRIES C ON C.ID = A.COUNTRYID
	INNER JOIN CITIES CT ON CT.ID = A.CITYID
	INNER JOIN TOWNS T ON T.ID = A.TOWNID
	INNER JOIN PAYMENTS P ON P.ORDERID=O.ID



CREATE FUNCTION DBO.TOPLA(@SAYI1 AS INT,@SAYI2 AS INT)
	RETURNS INT
	AS
	BEGIN
	DECLARE @SONUC AS INT
	SET  @SONUC = @SAYI1 + @SAYI2
	RETURN @SONUC
	END

SELECT DBO.TOPLA(20,30)

CREATE FUNCTION DBO.CALCULATE_AGE(@BIRTHDATE AS DATE)
	RETURNS INT
	AS
	BEGIN
	DECLARE @RESULT AS INT
	SET @RESULT = DATEDIFF(YEAR,@BIRTHDATE,GETDATE())
	RETURN @RESULT
	END

SELECT DBO.CALCULATE_AGE(U.BIRTHDATE) FROM USERS U


-- AD HOC QUERY --
/*
	SQL'DE GEÇİCİ BİR SORGUDUR. DEĞERİ BAZI DEĞİŞKENLERE BAĞLI OLAN BİR SORGU TÜRÜDÜR
	KOMUT HER YÜRÜTÜLDÜĞÜNDE DEĞİKENİN DEĞERİNE BAĞLI OLARAK SONUÇ FARKLIDIR.
	GEÇİCİ BİR SORGU VE KISA ÖMÜRLÜDÜR.
	"Ad hoc" kelimesinin önerdiği gibi, bu tür bir sorgu, her yürütmede aynı çıktı değerine sahip olan önceden tanımlanmış bir sorgunun aksine "belirli bir amaç" için tasarlanmıştır. Ad hoc sorgu, sistemde uzun süre kalmaz ve kullanıcı tarafından isteğe bağlı olarak dinamik olarak oluşturulur. Sistem kaynaklarından tasarruf sağladığı için programlamada geçici bir sorgu kullanmak daha verimlidir, ancak aynı zamanda karmaşık, geçici sorgular (birden çok değişkene sahiptir) ayrıca sistemin işlem hızını ve çalışma zamanı belleğini de zorlar.
	EK KAYNAK:
		https://www.techopedia.com/definition/30581/ad-hoc-query-sql-programming
*/

INSERT INTO WORKER(
	[WORKERCODE], [WORKERNAME], [GENDER], [BIRTHDATE], [TCKN], [WORKERBARCODE]
)
VALUES ('12345678900','MEHMET DEMİREL','E','19900101','12345678900',NEWID())
SELECT * FROM WORKER

INSERT INTO WORKERTRANSACTIONS(
	[WORKERID], [DATE_], [IOTYPE], [GATEID]
)
VALUES(1,'2021-04-12 13:01:01','G',1)

SELECT * FROM WORKERTRANSACTIONS

TRUNCATE TABLE WORKERTRANSACTIONS


-- RAISERROR --
-- HATA DERECELERİ --
https://docs.microsoft.com/en-us/sql/relational-databases/errors-events/database-engine-error-severities?view=sql-server-ver15
-- SYNTAX --
/*
	RAISERROR ( { msg_id | msg_str | @local_variable }  
    { ,severity ,state }  
    [ ,argument [ ,...n ] ] )  
    [ WITH option [ ,...n ] ]  
*/
RAISERROR('YOUR ERROR MESSAGE',16,1)

---------------------------------------------------------------

CREATE PROC SP_WORKER_INOUT
	@WORKERBARCODE AS VARCHAR(50),
	@DATE AS DATETIME,
	@IOTYPE AS VARCHAR(1),
	@GATEID AS INT
AS
BEGIN
	DECLARE @WORKERNAME AS VARCHAR(100)
	DECLARE @WORKERID AS INT
SELECT 
	@WORKERNAME = WORKERNAME, @WORKERID = ID 
FROM 
	WORKERS
WHERE WORKERBARCODE = @WORKERBARCODE

	IF @WORKERID IS NULL
		BEGIN
		RAISERROR('OKUTULAN KART GEÇERSİZDİR',16,1)
		RETURN
		END
	DECLARE @LASTIO AS VARCHAR(1)
	SELECT 
		TOP 1 @LASTIO = IOTYPE 
	FROM 
		WORKERTRANSACTIONS
	WHERE WORKDERID = @WORKERID AND DATE_ >= CONVERT(DATE,GETDATE())
	ORDER BY
		DATE_ DESC
	IF @LASTIO = IOTYPE
		BEGIN
		IF @IOTYPE = 'G'
			BEGIN
			RAISERROR('ZATEN İÇERİDE GÖRÜNÜYORSUNUZ, GİRİŞ YAPAMAZSINIZ',16,1)
			END
		IF @IOTYPE = 'C'
			BEGIN
			RAISERROR('ZATEN DIŞARIDA GÖRÜNÜYORSUNUZ, ÇIKIŞ YAPAMAZSINIZ',16,1)
			END
		END
INSERT INTO WORKERTRANSACTIONS (WORKERID,DATE_,IOTYPE,GATEID)
VALUES(@WORKERID,@DATE,@IOTYPE,@GATEID)
SELECT @WORKERNAME AS WORKERNAME, @DATE AS DATE_,@IOTYPE AS IOTYPE
END

